\section{Forward vs. Backward}

\paragraph{Problem}
Implement and compare Repeated Forward A* and Repeated Backward A* with respect
to their runtime or, equivalently, number of expanded cells. Explain your
observations in detail, that is, explain what you observed and give a reason
for the observation. Both versions of Repeated A* should break ties among cells
with the same f-value in favor of cells with larger g-values and remaining ties
in an identical way, for example randomly.

\paragraph{Solution}

As Table \ref{tbl:rfa-rba} shows, the Repeated Backward A* expands more cells
than RFA*. On average, for each map, RBA* takes time (namely the expanded
cells) 15 times more than RFA*. In addition, in each procedure of computing 
path, RBA* also expands cells over 10 times more than RFA*. So the efficiency
of RBA* is much worse than that of RFA*.

\begin{table}[h!]
\centering
\caption{Result of Repeated Forward A* and Repeated Backward A*}
\begin{tabular}{|l|l|l|l|l|}
\hline
Algorithm & Aver. Expa/M & aver. Expa/P & Aver. Expl/M & Aver. Expl/P \\
\hline
RFA* & 8847.88 & 92.44 & 25461.42 & 267.68 \\
\hline
RBA* & 133043 & 1272.54 & 266050.76 & 2551.44 \\
\hhline{|=|=|=|=|=|}
Algorithm & Aver. Moves & Aver. Count & Aver. Optimal & Aver. Ratio \\
\hline
RFA* & 335.72 & 88.2 & 198.6 & 1.6852 \\
\hline
RBA* & 390.88 & 103.4 & 198.6 & 1.9626 \\
\hline
\end{tabular}
\label{tbl:rfa-rba}
\end{table}

The reason is that, at the beginning of search, RFA* can use the knowledge from 
moving to discover which cells are blocked, thus it can immediately avoid
calculating those possible shortest paths that are blocked by obstacles on the
way. In contrast, RBA* searches from the goal, and cells near the goal are
still unknown. So RBA* will find blocked cells very late, which may result in
the defect that RBA* has to compute another path from an early cell it has expanded. 
Thus RBA* will cost more time and expand more cells to find the shortest path.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{RBA-1.png}
    \caption{RBA* before computing}
    \label{fig:p3-rba-1}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{RBA-2.png}
    \caption{RBA*  after computing}
    \label{fig:p3-rba-2}
  \end{subfigure}
  \caption{Example of RBA* procedure for computing path}
  \label{fig:p3-rba}
\end{figure}

For example, in the Figure \ref{fig:p3-rba}, denote each cell as $c(i,j)$,
where $i,j$ is the row number and column number from 1 to 8. In the Figure
\ref{fig:p3-rba-1}, the agent encounters a blocked cell $c(1,3)$, then it has
to compute the path again. Using RBA* search, it will compute the path from
goal.  When it reaches $c(1,4)$ along the yellow path near the agent, it will
find its adjacent cell $c(1,3)$ is blocked. Then it has to turn down to
$c(2,4)$. However, when the cell $c(2,8)$ was expanded, its left cell $c(2,7)$
was added to $OPEN$ list. Then we have
$$f(c(2,7)) = h(c(2,7)) + g(c(2,7)) = 6 + 7 = 13$$
and
$$f(c(2,4)) = h(c(2,4)) = 3 + 12 =15$$
So, the procedure will choose $c(2,7)$ to expand and there will be a new path in
this procedure of computing path, like the Figure \ref{fig:p3-rba}.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{RFA-1.png}
    \caption{RFA* before computing}
    \label{fig:p3-rfa-1}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{RFA-2.png}
    \caption{RFA* after computing}
    \label{fig:p3-rfa-2}
  \end{subfigure}
  \caption{Example of RFA* procedure of computing path}
  \label{fig:p3-rfa}
\end{figure}

In contrast, as Figure \ref{fig:p3-rfa} shows, when RFA* computes the path, it
will immediately find $c(3,1)$ is blocked, thus it will avoid adding it to the
shortest path at once. Then it will not expand extra cells.

